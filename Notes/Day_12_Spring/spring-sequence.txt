Why Spring ?
Simplifies overall java development

What is it ?
container --manages life cycle of spring beans
(spring bean --- java obj whose life cycle completely managed by SC(spring container)
eg : rest controller, controller, service,DAO.
framework --rdy made implementation of std patterns(eg :MVC,Proxy,singleton,factory, ORM ...)
Spring is modular n extensive framework.

Why Spring : loosely coupled application
Via : D.I / AOP

What is dependency injection ?
In JSP---JB---DAO(Utils) -- POJO --DB layers
Dependent Objs -- JavaBean , Hibernate based DAO, JDBC Based DAO
Dependencies --- DAO,HibUtils(SessionFactory) , DBUtils(DB connection)

All of above are examples of tight coupling.

Why --Any time the nature of the dependency changes , dependent obj is affected(i.e u will have to make changes in dependent obj)
eg : When the dependency of Java Bean changes from JDBC Based DAO to Hibernate based DAO , in case of user authentication , javabean class has to be modified to handle invalid login case(i.e handle NoResultException)

Tight coupling --strongly un desirable.
Why -- difficult to maintain or extend.

In above examples , Java bean creates the instance of DAO.
Hibernate based DAO , gets SF from HibUtils.
JDBC based DAO ,gets db connection from DBUtils.

i.e dependent objects are managing their dependencies. ---traditional/conventional programming model.

What is D.I ?(Dependency injection=wiring=collaboration between dependent & dependency)
Instead of dependent objs managing their dependencies , 3rd party containers(eg : Angular / Spring/ EJB/ WC) will auto create the dependecies & make it available to dependents, directly @ run time.

Since dependent are no longer managing dependencies --its called as IoC ---Inversion of control

Hollywood principle --You don't call us , we will call you....
SC --- > Dependent objs (i.e SC will create the dependencies for the dependent objs)

eg : UserController
@Autowired
private IUserService service;

In DAO layer
@AutoWired
private SessionFactory sf;

More details about <bean> tag 
Attributes
1. id --mandatory --bean unique id
2. class --- mandatory -- Fully qualified bean class name
3. scope --- In Java SE --- singleton | prototype

   In web app singleton | prototype | request | session | global session
   Default scope = singleton
   singleton --- SC will share single bean instance for multiple requests/demands(via ctx.getBean)
   prototype -- SC creates NEW bean instance per  request/demand.

4. lazy-init --- boolean attribute. default value=false.
   Applicable only to singleton beans.
   SC will auto create singleton spring bean instance --- @ SC start up.

5. init-method --name of init style method(public void anyName() throws Exception{..})
   called by SC after setter based D.I

6. destroy-method --name of destroy style method
   (public void anyName() throws Exception{..})
   called by SC before GC of spring bean (applicable only to singleton beans)

API 
How to get ready to use spring beans from SC ?
API of BeanFactory
public <T> T getBean(String beanId,Class<T> beanClass) throws BeansException

-------------------------------------------------------------------------------------

Types of wiring 

XML based config

What are 3 different ways of supplying metadata instrs to SC
1. pure xml (legacy!)
2. Hybrid approach (lesser xml + majority annotations)
3. Java config class + annotations

1.Pure XML based approach(legacy)
<bean> tag attributes
id : unique bean id
class : F.Q bean class name
scope : 
Java SE : singleton | prototype
def scope : singleton (=> SC creates a single instance of this bean : to be shared across multiple demands i.e getBean)
prototype : => SC creates a separate  instance of the bean : as per demand i.e getBean)
lazy-init : def value =false (applicable to ONLY singleton beans)

init-method : name of custom init method
pattern : public void anyName() throws Exc {....}
Will be invoked for singleton as well as prototype beans

destroy-method : name of custom destroy  method : SC invokes it just before GC
pattern : public void anyName() throws Exc {....}
Will be invoked only for  singleton beans

How to launch SC in a standalone application ?

Understand SC API (refer to a diagram)
API 
How to get ready to use spring beans from SC ?
API of BeanFactory
public <T> T getBean(String beanId,Class<T> beanClass) throws BeansException
T : type of the spring bean 

Different Modes of Wiring (D.I.) : (refer to a diagram)

-----------------------------------------------------------------------------------

2. Hybrid Approach (reduced XML n majority annotations)
Steps in Spring programming using annotations

0. To enable annotation support -- add context namespace & add the following
<context:annotation-config/> --- To tell SC --to enable annotation support(eg --- AutoWired,PostConstruct,Predestroy,.....)

0.5 --- How to specify location(base pkg) of spring beans to SC?
<context:component-scan base-package="comma sep list of pkgs"/>---
SC starts searching(scanning)  in specified pkgs (including sub-pkgs) ---for classes anno with stereotype annotations --- @Component,@Service,@Repository,@Controller,@RestController,@ControllerAdvice...

Basic class level annotations meant for  SC
Super type 
@Component --- spring bean class
sub - type annotations
@Controller --- In Web MVC scenario -- for request handling.
@Service --- Service layer (B.L) + transaction management
@Repository --- DAO layer
@RestController -- RESTful service provider

1. @Component --- <bean id , class....> --- SC interprets it & starts bean life-cycle.
eg --- 
package beans;
@Component("abc")
public class MyBean {...}
xml --- <bean id="abc" class="beans.MyBean"/>
	OR
@Component
public class MyBean {...}
xml --- <bean id="myBean" class="beans.MyBean"/>

2. @Controller -- spring web MVC req handling controller
3. @Repository --- DAO layer class
4. @Service --- for service layer beans(B.L) .
5. @Scope(value="singleton|prototype|request|session")--- class level annotaion --- in xml via scope attribute.
6. @Lazy(true|false) ----class level anno -- lazy-init attribute
7. @PostConstruct ---method level anno - init-method ---method level
8. @PreDestroy ---method level anno-- destroy-method --- method level
9. @Required(true|false) --- setter method or paramed constr  ---tells SC if depenency is mandatory or optional-- def=true
10. @AutoWired ---setter method or parameterized constr or any method or  field level 
	eg --- TestTransport implements Transport {...}
 	autowire="byType"
	eg  -- field level annotation ---in ATMImpl bean (dependent)
	@AutoWired //autowire=byType , mandatory by default (required=true)
	private Transport myTransport;
	Meaning -- no parameterised constr, no setter , no xml containing bean definition is required.
	SC --- chks for any bean of Transport by type & injects it in ATMImpl
	What if : SC comes across multiple matches : SC throws NoUniqueBeanDefinitionException
	What if : SC doesn't find even a single match : SC throws UnSatisfiedDependencyException

11. @AutoWired//(required=true)
@Qualifier("test")
	private Transport myTransport; ---- =>autowire="byName"
	---spring supplied anno.
	SC searches for a bean with id="test"
 
	Single Match found : NO excs , field level D.I succeds!
	Match not found : SC throws exception (UnSatisfiedDependencyException : NoBeanDefFoundExc)
	Multiple Matches Found : Ambiguity => SC throws NoUniqueBeanDefinitionException

	OR
	@Resource(name="soap")
	private Transport myTransport; ---- autowire="byName"

-----------------------------------------------------------------------------------

SpEL --- spring expression language
dynamic expression languge ---spring(3.x) supplied -- to evaluate expressions dynamically.
#{SpEL expression} --- similar to  JSP EL --- SpEL allows --- getters,setters,constr invocation, static & non-static method invocations.
OR
${SpEL expr}

-----------------------------------------------------------------------------------